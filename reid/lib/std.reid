
extern fn puts(message: *char) -> i32;
extern fn malloc(size: u64) -> *u8;
extern fn free(ptr: *u8);
extern fn div(numerator: i32, denominator: i32) -> div_t;

struct div_t {
    quotient: i32,
    remainder: i32,
}

pub fn print(message: String) {
    puts(message.inner);
}

pub fn int_div(numerator: i32, denominator: i32) -> div_t {
    return div(numerator, denominator);
}

pub fn allocate(size: u64) -> *u8 {
    malloc(size)
}

struct String {
    inner: *char,
    length: u64,
    max_length: u64,
    must_be_freed: bool,
}

pub fn new_string() -> String {
    String {
        inner: allocate(0),
        length: 0,
        max_length: 0,
        must_be_freed: true,
    }
}

pub fn from_str(str: *char) -> String {
    let length = str_length(str);
    let mut new = new_string();
    let static = String {
        inner: str,
        length: length - 1,
        max_length: length,
        must_be_freed: false,
    };
    concat_strings(&mut new, static);
    return new;
}

pub fn add_char(string: &mut String, c: char) {
    if ((*string).length + 1) >= (*string).max_length {
        let new = allocate((*string).max_length + 4) as *char;
        copy_bits((*string).inner, new, (*string).max_length);

        if (*string).must_be_freed == true {
            free((*string).inner as *u8);
        }
        (*string).max_length = (*string).max_length + 4;
        (*string).inner = new;
        (*string).must_be_freed = true;
    }

    (*string).inner[(*string).length] = c;
    (((*string).inner) as *u8)[(*string).length + 1] = 0;
    (*string).length = (*string).length + 1;
}

pub fn set_char(string: &mut String, c: char, position: u64) {
    if position <= (*string).length {
        (*string).inner[position] = c;
    }
}

pub fn free_string(string: &String) {
    free((*string).inner as *u8);
}

fn copy_bits(from: *char, to: *char, length: u64) {
    for i in 0 .. length {
        to[i] = from[i];
    }
}

fn str_length(string: *char) -> u32 {
    let mut pos = 0;
    while ((string[pos] == '\0') == false) {
        pos = pos + 1;
    }
    return pos + 1;
}

pub fn add_num_to_str(string: &mut String, num: u64) {
    if num >= 10 {
        add_num_to_str(string, num / 10)
    }
    let rem = num % 10;

    if rem == 0 { add_char(string, '0'); } 
    else if rem == 1 { add_char(string, '1'); }
    else if rem == 2 { add_char(string, '2'); }
    else if rem == 3 { add_char(string, '3'); }
    else if rem == 4 { add_char(string, '4'); }
    else if rem == 5 { add_char(string, '5'); }
    else if rem == 6 { add_char(string, '6'); }
    else if rem == 7 { add_char(string, '7'); }
    else if rem == 8 { add_char(string, '8'); }
    else if rem == 9 { add_char(string, '9'); }
}

pub fn concat_strings(destination: &mut String, source: String) {
    for i in 0 .. (str_length(source.inner) - 1) {
        add_char(destination, source.inner[i]);
    }
}

pub fn clamp(min: f32, max: f32, value: f32) -> f32 {
    if value > max {
        return max;
    }
    if value < min {
        return min;
    }
    return value;
}

pub fn abs(f: f32) -> f32 {
    if f < 0.0 {
        return f * (0.0 - 1.0);
    }
    return f;
}
