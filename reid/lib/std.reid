
extern fn puts(message: *char) -> i32;
extern fn malloc(size: u64) -> *u8;
extern fn free(ptr: *u8);
extern fn div(numerator: i32, denominator: i32) -> div_t;

struct div_t {
    quotient: i32,
    remainder: i32,
}

pub fn print(message: &String) {
    puts(*message.inner);
}

pub fn int_div(numerator: i32, denominator: i32) -> div_t {
    return div(numerator, denominator);
}

pub fn allocate(size: u64) -> *u8 {
    malloc(size)
}

struct String {
    inner: *char,
    length: u64,
    max_length: u64,
    must_be_freed: bool,
}

pub fn new_string() -> String {
    String {
        inner: allocate(0),
        length: 0,
        max_length: 0,
        must_be_freed: true,
    }
}

pub fn from_str(str: *char) -> String {
    let length = str_length(str, 0);
    let cloned = malloc(length as u64) as *char;
    copy_bits(str, cloned, 0, length as u64);
    return String {
        inner: cloned,
        length: length,
        max_length: length,
        must_be_freed: false,
    };
}

pub fn add_char(string: &mut String, c: char) {
    if ((*string).length + 1) >= (*string).max_length {
        let new = allocate((*string).max_length + 4) as *char;
        copy_bits((*string).inner, new, 0, (*string).max_length);

        if (*string).must_be_freed == true {
            free((*string).inner as *u8);
        }
        (*string).max_length = (*string).max_length + 4;
        (*string).inner = new;
        (*string).must_be_freed = true;
    }

    (*string).inner[(*string).length] = c;
    (((*string).inner) as *u8)[((*string).length + 1)] = 0;
    (*string).length = (*string).length + 1;
}

pub fn set_char(string: &mut String, c: char, position: u64) {
    if position <= (*string).length {
        (*string).inner[position] = c;
    }
}

pub fn free_string(string: &mut String) {
    free((*string).inner as *u8);
}

fn copy_bits(from: *char, to: *char, pos: u64, max: u64) -> u8 {
    if (pos >= max) {
        return 0;
    }
    to[pos] = from[pos];
    return copy_bits(from, to, pos + 1, max);
}

fn str_length(string: *char, position: u32) -> u32 {
    if (string[position] == '\0') {
        return 0;
    }
    return str_length(string, position + 1) + 1;
}

pub fn add_num_to_str(string: &mut String, num: u64) {
    if num > 10 {
        add_num_to_str(string, num / 10)
    }
    let rem = num % 10;

    if rem == 0 { add_char(string, '0'); } 
    else if rem == 1 { add_char(string, '1'); }
    else if rem == 2 { add_char(string, '2'); }
    else if rem == 3 { add_char(string, '3'); }
    else if rem == 4 { add_char(string, '4'); }
    else if rem == 5 { add_char(string, '5'); }
    else if rem == 6 { add_char(string, '6'); }
    else if rem == 7 { add_char(string, '7'); }
    else if rem == 8 { add_char(string, '8'); }
    else if rem == 9 { add_char(string, '9'); }
}